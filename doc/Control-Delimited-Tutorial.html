<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Delimited.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Delimited-Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Delimited-Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">asai-0.0.0.0: A minimal library for delimited continuations.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>mad.one@gmail.com</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Control.Delimited.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction
</a></li><li><a href="#g:2">An primer on continuations
</a><ul><li><a href="#g:3">Undelimited
</a></li><li><a href="#g:4">Delimited
</a></li></ul></li><li><a href="#g:5">Examples
</a><ul><li><a href="#g:6">Simple answer-type modification
</a></li><li><a href="#g:7">First-class <code>printf</code>
</a></li><li><a href="#g:8">Walking binary trees
</a></li></ul></li><li><a href="#g:9">Other notes
</a><ul><li><a href="#g:10">Indexed monads
</a></li><li><a href="#g:11">Using <code>do</code>-notation
</a></li><li><a href="#g:12">Rank-2 typing
</a></li></ul></li><li><a href="#g:13">Further reading
</a></li><li><a href="#g:14">References
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides an introductory tutorial in the
 &quot;Introduction&quot; section and beyond, followed by examples, and by
 some discussion behind the theory of the library with references.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"></ul></div><div id="interface"><h1 id="g:1">Introduction
</h1><div class="doc"><p><code>asai</code> is a minimal library for <em>delimited continuations</em>, a <code>slice</code>
of a continuation that can be invoked as a function and composed.
</p></div><h1 id="g:2">An primer on continuations
</h1><div class="doc"><p>Continuations are a well known abstraction for 'picking up where you
left off.' When you use <code>call/cc</code> traditionally in something like
scheme, you pass it a function <code>f</code> which receives a function <code>k</code>, and
when <code>k</code> is invoked you 'call the continuation' and return where
<code>call/cc</code> left off. In this sense, <code>k</code> is a reification of the state
you were in when you invoked <code>f</code>.
</p><p>But <code>call/cc</code> is, as some say, 'overrated.' For one, it is not
possible to return a value from the continuation; you merely pick up
where you left off. By fixing this we get delimited continuations: an
abstraction that allows us to slice up a continuation and compose
them. But at this point, we suffer in a statically typed language: the
type of <code>shift</code> and <code>reset</code> are not polymorphic in their return.
</p><p>In the same way that continuations form a monad, so do delimited
continuations. This package provides a delimited continuation monad
which implements truly polymorphic <code>shift</code> and <code>reset</code> operators, via
<em>answer type polymorphism</em>, which allows the results of a delimited
computation to vary.
</p><p>This implementation (using indexed monads) was first implemented
by - and this package derived from - Oleg Kiselyov [1]. It directly
implements the typing rules of Kenichi Asai's lambda/shift calculus
[2], featuring answer type polymorphism and modification.
</p><p>A general tutorial on delimited continuations in OchaCaml (with code
in Haskell and OCaml) from Asai/Kiselyov is available [3]. A more
traditional delimited continuation monad is available in the
<code>CC-delcont</code> package [4]. The <code>CC-delcont</code> tutorial [5] serves
as a basis for this tutorial (thanks to Dan Doel!)
</p></div><h2 id="g:3">Undelimited
</h2><div class="doc"><p>Lorem ipsum...
</p></div><h2 id="g:4">Delimited
</h2><div class="doc"><p>Lorem ipsum...
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runDelim $ reset $ shift1 (\_ -&gt; ret &quot;hello&quot;) !&gt;&gt;= \r -&gt; ret (r + 1)
</code></strong>&quot;hello&quot;
</pre></div><h1 id="g:5">Examples
</h1><div class="doc"><p>In the subsequent sections, we'll cover some examples of using this
library in a few simple forms, which should form a basis for reasoning
about how to use it. The same ideas should apply to other delimited
continuation libraries or interfaces (i.e. scheme, ocaml, ochacaml,
etc.)
</p></div><h2 id="g:6">Simple answer-type modification
</h2><div class="doc"><p>Lorem ipsum...
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runDelim $ reset $ shift1 (\_ -&gt; return &quot;hello&quot;) &gt;&gt;= \r -&gt; return (r + 1)
</code></strong>&quot;hello&quot;
</pre></div><h2 id="g:7">First-class <code>printf</code>
</h2><div class="doc"><p>Lorem ipsum...
</p></div><h2 id="g:8">Walking binary trees
</h2><div class="doc"><p>Here, we will...
</p><pre> 
 -- Walking trees with coroutines.
 -- Based on:
 --    &lt;http://okmij.org/ftp/continuations/ContExample.hs&gt;
 module Tree where

 import Control.Delimited

 -- Binary trees
 data Tree a
   = Leaf
   | Node (Tree a) (Tree a) a
   deriving (Show, Eq)

 make_tree :: Int -&gt; Tree Int
 make_tree j = go j 1
   where go 0 _ = Leaf
         go i x = Node (go (i-1) $ 2*x) (go (i-1) $ 2*x+1) x

 tree1 = make_tree 3
 tree2 = make_tree 4

 -- Coroutines as lazy monadic lists.
 data Coro a
   = Done
   | Resume a (forall s. Delim s s (Coro a))

 walk_tree x = runDelim (walk_tree' x !&gt;&gt; ret Done)

 walk_tree' Leaf = ret ()
 walk_tree' (Node l r x) =
   walk_tree' l !&gt;&gt;
   yield x      !&gt;&gt;
   walk_tree' r
   where
     yield n = shift2 (\k -&gt; ret $ Resume n $ k ())

 walk1 t = go (walk_tree t)
   where
     go Done         = return ()
     go (Resume x k) = print x &gt;&gt; go (runDelim k)
</pre><p>The full code is available in <code>examples/Tree.hs</code>.
</p></div><h1 id="g:9">Other notes
</h1><div class="doc"><p>Here we discuss some of the design aspects of the library,
particularly for those wondering why we need indexed (or
<em>indexed</em>) monads, and how we can reconcile this with <code>do</code>-notation.
</p></div><h2 id="g:10">Indexed monads
</h2><div class="doc"><p>While reading this tutorial, you may wonder why we use special
operators (like <code><a href="Control-Indexed-Monad.html#v:-33--62--62--61-">!&gt;&gt;=</a></code> that mimmick <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Prelude.html#t:-62--62--61-">&gt;&gt;=</a></code>) for delimited
computations, instead of regular operators from the <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Control-Monad.html#t:Monad">Monad</a></code>
typeclass. The reason for this is that in order to ensure the answer
type of delimited computation is polymorphic, we need the monad to
'carry' the answer types around.
</p><p>Consider the vanilla <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Control-Monad.html#t:Monad">Monad</a></code> typeclass. It is defined like this (with
explicit kind signatures):
</p><pre> class Monad (m :: * -&gt; *) where ...
</pre><p>The <code>m</code> type constructor abstracts over a single type variable. It is
possible to make types with multiple type variables an instance of
<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Control-Monad.html#t:Monad">Monad</a></code> of course, but their non-abstracted type variables must be
fixed. As an example, considering the instance for <code><code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Data-Either.html#t:Either">Either</a></code> e</code>:
</p><pre> instance Monad (Either e) where ...
</pre><p>Note the type variable <code>e</code> is fixed over the definition of a term of
type <code>Either e :: * -&gt; *</code>. If you have something like:
</p><pre> thing :: a -&gt; Either String a
 thing a = do
   ...
</pre><p>Then in the body we may say:
</p><pre> x &lt;- Left &quot;oh no!&quot;
</pre><p>But we can never say:
</p><pre> x &lt;- Left False
</pre><p>because <code>e</code> is fixed to <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Data-String.html#t:String">String</a></code>.
</p><p>Indexed monads solve this problem by 'expanding' the kind of <code>m</code> in
the <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Control-Monad.html#t:Monad">Monad</a></code> typeclass. The result is <code><a href="Control-Indexed-Monad.html#t:IxMonad">IxMonad</a></code>, which is defined as:
</p><pre> class IxMonad (m :: * -&gt; * -&gt; * -&gt; *) where
   ret    :: t -&gt; m a a t
   (!&gt;&gt;=) :: m b g s -&gt; (s -&gt; m a b t) -&gt; m a g t
</pre><p>Note the new type variables: these represent the input and output
answer types of a delimited computation. We can see that <code><a href="Control-Indexed-Monad.html#v:ret">ret</a></code> is
fully polymorphic in its answer type: a statement of <code>ret foo</code> in a
<code><a href="Control-Delimited.html#t:Delim">Delim</a></code> simply does not change the answer type at all. Note the answer
types present in <code><a href="Control-Indexed-Monad.html#t:-33--62--62--61-">!&gt;&gt;=</a></code>: we have an answer type
of <code>a b</code> and <code>b g</code>, meaning we can get an overall answer type of <code>a
g</code>.
</p><p>This polymorphism in the definition of <code><a href="Control-Indexed-Monad.html#t:-33--62--62--61-">!&gt;&gt;=</a></code> is
what gives us answer type polymorphism: it means delimited
computations may change the output answer type.
</p></div><h2 id="g:11">Using <code>do</code>-notation
</h2><div class="doc"><p>It's possible to use GHC's <code>RebindableSyntax</code> extension to re-define
<code>do</code> notation to use the <code><a href="Control-Indexed-Monad.html#t:IxMonad">IxMonad</a></code> type class.
</p><p>Begin your module by hiding the regular <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Control-Monad.html#t:Monad">Monad</a></code> methods, and then
redefine <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Prelude.html#t:-62--62--61-">&gt;&gt;=</a></code> and <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Prelude.html#t:return">return</a></code>. Feel free to redefine
other operators too. Here's an example (you'll need to fix the
<code>LANGUAGE</code> pragma yourself on the first line, since Haddock eats it
otherwise):
</p><pre> [-# LANGUAGE RebindableSyntax, NoImplicitPrelude #-]
 module Foo where

 import Control.Indexed.Prelude
 import Control.Delimited

 -- Now use 'do' notation instead of the indexed bind/return
 -- functions.

 -- You can lift regular monads into indexed monads using
 -- 'lift' and 'runI'
 io1 :: IO ()
 io1 = runI $ do
   lift $ putStrLn &quot;hi!&quot;
   lift $ putStrLn &quot;hi!&quot;
   return ()

 test1 :: String
 test1 = runDelim $ reset $ do
   r &lt;- shift1 (\_ -&gt; return &quot;hello&quot;)
   return (r + 1)
 -- This is equivalent to the OchaCaml term:
 --   reset (fun () -&gt; 1 + shift (fun _ -&gt; &quot;hello&quot;)) ;;
</pre><p>See <code>examples/Simple.hs</code> (included in the distribution) for several
more examples.
</p></div><h2 id="g:12">Rank-2 typing
</h2><div class="doc"><p>This package requires GHC's <code>RankNTypes</code> extension, as it uses a
rank-2 type for the definition of the <code>shift</code> operators <code><a href="Control-Delimited.html#v:shift2">shift2</a></code> and
<code><a href="Control-Delimited.html#v:shift3">shift3</a></code>. The original implementation by Kiselyov is Haskell98 (he
defines <code>shift</code> as the <code><a href="Control-Delimited.html#v:shift1">shift1</a></code> provided in this package, as opposed
to <code><a href="Control-Delimited.html#v:shift2">shift2</a></code> which matches the typing rules of the lambda/shift
calculus.)
</p><p>Strictly speaking, the rank-2 type is probably not necessary, but it
is not very controversial either, and it makes the intent much
clearer.
</p><p>You do not <em>necessarily</em> need to enable <code>RankNTypes</code> to use this
package, but in certain cases where you need to be polymorphic over
recursive uses of <code><a href="Control-Delimited.html#t:Delim">Delim</a></code> for example, it will be necessary to
quantify the answer type variables with a rank-2 type. However,
because the provided family of <code>shift</code> operators is equivalent, you
should be able to get by without <code>RankNTypes</code> should you choose.
</p></div><h1 id="g:13">Further reading
</h1><div class="doc"><p>Lorem ipsum...
</p></div><h1 id="g:14">References
</h1><div class="doc"><ol><li> <em>Genuine shift\reset in Haskell98</em>, by Kiselyov, on <em>haskell-cafe</em>:
     <a href="http://okmij.org/ftp/continuations/implementations.html#genuine-shift">http://okmij.org/ftp/continuations/implementations.html#genuine-shift</a>
</li><li> <em>Polymorphic Delimited Continuations</em>, by Asai, Kameyama in <em>APLAS '07</em>:
     <a href="http://logic.cs.tsukuba.ac.jp/~kam/paper/aplas07.pdf">http://logic.cs.tsukuba.ac.jp/~kam/paper/aplas07.pdf</a>
</li><li> <em>Introduction to programming with shift and reset</em>, by Kiselyov, Asai, in <em>CW2011</em>:
      <a href="http://okmij.org/ftp/continuations/index.html#tutorial">http://okmij.org/ftp/continuations/index.html#tutorial</a>
</li><li> <em>CC-delcont: Delimited continuations and dynamically scoped variables</em>: <a href="http://hackage.haskell.org/package/CC-delcont">http://hackage.haskell.org/package/CC-delcont</a>
</li><li> <em>CC-delcont introduction: &lt;http:</em><em>www.haskell.org</em>haskellwiki<em>Library</em>CC-delcont#CC-delcont&gt;
</li></ol></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.1</p></div></body></html>