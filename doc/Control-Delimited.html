<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Delimited</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Delimited.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Delimited.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">asai-0.0.0.0: A minimal library for delimited continuations.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>Rank-2 types required</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>mad.one@gmail.com</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Control.Delimited</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Delimited continuations
</a><ul><li><a href="#g:2">A family of shift operators
</a></li><li><a href="#g:3">Executing delimited computations
</a></li></ul></li><li><a href="#g:4">Re-exports for convenience
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Delimited continuations featuring answer-type polymorphism, via
 indexed monads.
</p><p>There is a tutorial available in <a href="Control-Delimited-Tutorial.html">Control.Delimited.Tutorial</a>.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Delim">Delim</a> s t b</li><li class="src short"><a href="#v:reset">reset</a> ::  <a href="Control-Delimited.html#t:Delim">Delim</a> s t s -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a a t</li><li class="src short"><a href="#v:shift0">shift0</a> ::  ((b -&gt; s) -&gt; t) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b</li><li class="src short"><a href="#v:shift1">shift1</a> ::  ((b -&gt; s) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a t a) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b</li><li class="src short"><a href="#v:shift2">shift2</a> ::  ((b -&gt; <span class="keyword">forall</span> a'.  <a href="Control-Delimited.html#t:Delim">Delim</a> a' a' s) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a t a) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b</li><li class="src short"><a href="#v:shift3">shift3</a> ::  ((<span class="keyword">forall</span> a'.  <a href="Control-Delimited.html#t:Delim">Delim</a> a' a' b -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a' a' s) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a t a) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b</li><li class="src short"><a href="#v:runDelim">runDelim</a> ::  <a href="Control-Delimited.html#t:Delim">Delim</a> t t t -&gt; t</li><li class="src short">module <a href="Control-Indexed-Monad.html">Control.Indexed.Monad</a></li></ul></div><div id="interface"><h1 id="g:1">Delimited continuations
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Delim" class="def">Delim</a> s t b <a href="src/Control-Delimited.html#Delim" class="link">Source</a></p><div class="doc"><p>The type of a delimited continuation, which is answer-type
 polymorphic.
</p><p>Functions of type <code>a -&gt; <code><a href="Control-Delimited.html#t:Delim">Delim</a></code> s t b</code> can be thought of as
 functions of type <code>a / s -&gt; b / t</code>, which means given an <code>a</code> we
 return <code>b</code>, changing the <em>answer type</em> of the delimited computation
 from <code>s</code> to <code>t</code>. The take away from this is that the <code>s</code> and <code>t</code>
 variables representing the input and output answer type,
 respectively. (This notation is used in both OchaCaml and the
 definition of Asai's lambda/shift calculus.)
</p><p>If a <code><a href="Control-Delimited.html#t:Delim">Delim</a></code> operation does not capture the computation using one
 of the various <code>shift</code> operators (or <code>shift</code> does not change the
 answer type,) then the term is <em>polymorphic</em> in the answer type.
</p><p>Consider a term like:
</p><pre>
 reset $ [...] !&gt;&gt;= \r -&gt; ret $ r ++ &quot; world&quot;
</pre><p>Here, the answer type of the enclosing <code><a href="Control-Delimited.html#v:reset">reset</a></code> is <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Data-String.html#t:String">String</a></code>. If the
 hole (specified by <code>[...]</code>) does not have a <code>shift</code> operator, or
 the <code>shift</code> operator does not change the answer type, then the type
 of the hole is answer type polymorphic: the hole cannot change the
 answer type of the enclosing <code><a href="Control-Delimited.html#v:reset">reset</a></code>.
</p><p>To make this clearer, consider using a <code>shift</code> operator to return
 the delimited continuation to the outer <code><a href="Control-Delimited.html#v:reset">reset</a></code> (which does not
 modify the answer type, since we can only invoke <code>k</code> to return an
 <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Data-Int.html#t:Int">Int</a></code>):
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t runDelim $ reset $ shift2 (\k -&gt; ret k) !&gt;&gt;= \r -&gt; ret (r + (1::Int))
</code></strong>runDelim $ reset $ shift2 (\k -&gt; ret k) !&gt;&gt;= \r -&gt; ret (r + (1::Int))
  :: Int -&gt; Delim a' a' Int
</pre><p>Note how the quantified variable <code>a'</code> is both the input and output
 answer type of <code>k</code>: thus, it cannot change the answer type (here we use
 <code><a href="Control-Delimited.html#v:shift2">shift2</a></code> which features a rank-2 type, perfectly matching the same
 kind of type you would see in OchaCaml.)
</p></div><div class="subs instances"><p id="control.i:Delim" class="caption collapser" onclick="toggleSection('i:Delim')">Instances</p><div id="section.i:Delim" class="show"><table><tr><td class="src"><a href="Control-Indexed-Monad.html#t:IxMonad">IxMonad</a> <a href="Control-Delimited.html#t:Delim">Delim</a></td><td class="doc"><p>Delimited continuations form a indexed <code><a href="Control-Indexed-Monad.html#t:IxMonad">IxMonad</a></code>.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:reset" class="def">reset</a> ::  <a href="Control-Delimited.html#t:Delim">Delim</a> s t s -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a a t<a href="src/Control-Delimited.html#reset" class="link">Source</a></p><div class="doc"><p>Delimit a computation. The type variable <code>a</code> indicates that
 <code><a href="Control-Delimited.html#v:reset">reset</a></code> is polymorphic in its answer type.
</p></div></div><h2 id="g:2">A family of shift operators
</h2><div class="doc"><p>There exists not one, but a family of <code>shift</code> operators for delimited
continuations, which range in the purity of their constituent
continuation parameters and output types, from most pure to most
impure. This family of operators can be used to define each other in a
stepwise manner.
</p><p>Briefly, <code><a href="Control-Delimited.html#v:shift0">shift0</a></code> is the &quot;most pure <code>shift</code> of all&quot; in that the
delimited computation is completely pure. We may then use <code><a href="Control-Delimited.html#v:shift0">shift0</a></code> to
build the definition of <code><a href="Control-Delimited.html#v:shift1">shift1</a></code>, and use <code><a href="Control-Delimited.html#v:shift1">shift1</a></code> to build the
definition of <code><a href="Control-Delimited.html#v:shift2">shift2</a></code>, and so on until <code><a href="Control-Delimited.html#v:shift3">shift3</a></code>.
</p><p>We may then use <code><a href="Control-Delimited.html#v:shift3">shift3</a></code>, the &quot;most impure <code>shift</code> of all&quot;, to walk
back downards and define <code><a href="Control-Delimited.html#v:shift2">shift2</a></code>, and use <code><a href="Control-Delimited.html#v:shift2">shift2</a></code> to describe
<code><a href="Control-Delimited.html#v:shift1">shift1</a></code> and so on and so forth.
</p><p>We offer the full family of <code>shift</code> operators here, and where
appropriate we use rank-2 typing to ensure the answer types of a
computation are polymorphic (strictly speaking this likely isn't
necessary, but it makes the type signature far more clear and is
fairly non-controversial.)
</p><p>(Many thanks go to Leon P Smith who showed me notes describing this
family and 'zipper' of <code>shift</code> operators.)
</p></div><div class="top"><p class="src"><a name="v:shift0" class="def">shift0</a> ::  ((b -&gt; s) -&gt; t) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b<a href="src/Control-Delimited.html#shift0" class="link">Source</a></p><div class="doc"><p>Clear the current continuation and invoke our handler with it
 bound as a parameter.
</p><p>This is the most pure definition of <code>shift</code>: both the continuation
 <code>k</code> and the enclosed body are pure.
</p></div></div><div class="top"><p class="src"><a name="v:shift1" class="def">shift1</a> ::  ((b -&gt; s) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a t a) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b<a href="src/Control-Delimited.html#shift1" class="link">Source</a></p><div class="doc"><p>Clear the current continuation and invoke our handler with it
 bound as a parameter.
</p><p>This definition of <code>shift</code> prohibits the continuation <code>k</code> from
 being monadic, while allowing the body to be monadic (this means
 <code>k</code> is trivially polymorphic in its answer type, while remaining
 Haskell98.) For this reason it is less pure than <code><a href="Control-Delimited.html#v:shift0">shift0</a></code> but more
 pure than <code><a href="Control-Delimited.html#v:shift2">shift2</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:shift2" class="def">shift2</a> ::  ((b -&gt; <span class="keyword">forall</span> a'.  <a href="Control-Delimited.html#t:Delim">Delim</a> a' a' s) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a t a) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b<a href="src/Control-Delimited.html#shift2" class="link">Source</a></p><div class="doc"><p>Clear the current continuation and invoke our handler with it
 bound as a parameter.
</p><p>This definition of <code>shift</code> is the most &quot;genuine&quot; as it perfectly
 encapsulates the typing rules of Asai's lambda/shift calculus using
 rank-2 polymorphism: the continuation's answer type is fully
 polymorphic.
</p></div></div><div class="top"><p class="src"><a name="v:shift3" class="def">shift3</a> ::  ((<span class="keyword">forall</span> a'.  <a href="Control-Delimited.html#t:Delim">Delim</a> a' a' b -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a' a' s) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> a t a) -&gt; <a href="Control-Delimited.html#t:Delim">Delim</a> s t b<a href="src/Control-Delimited.html#shift3" class="link">Source</a></p><div class="doc"><p>Clear the current continuation and invoke our handler with it
 bound as a parameter.
</p><p>This is the most impure definition of <code>shift</code> in that all
 components of the delimited computation are monadic. It is akin to
 the definition of <code>withSubCont</code> in Amr Sabry's paper &quot;A Monadic
 Framework for Delimited Continuations&quot;, available in the
 <code>CC-delcont</code> package.
</p><p>Like <code><a href="Control-Delimited.html#v:shift2">shift2</a></code>, this uses rank-2 polymorphism to ensure that the
 continuation <code>k</code> is polymorphic in its answer type.
</p></div></div><h2 id="g:3">Executing delimited computations
</h2><div class="top"><p class="src"><a name="v:runDelim" class="def">runDelim</a> ::  <a href="Control-Delimited.html#t:Delim">Delim</a> t t t -&gt; t<a href="src/Control-Delimited.html#runDelim" class="link">Source</a></p><div class="doc"><p>Run a delimited computation.
</p></div></div><h1 id="g:4">Re-exports for convenience
</h1><div class="top"><p class="src">module <a href="Control-Indexed-Monad.html">Control.Indexed.Monad</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.1</p></div></body></html>